as.data.frame(lapply(df.lot, function(data){data[[1]]}),
col.names = 1:length(l.boot),
row.names = hist.perc$mids/100
)
df.lot.perc <-
as.data.frame(lapply(df.lot, function(data){data[[2]]}),
col.names = 1:length(l.boot),
row.names = hist.perc$mids/100
)
#LowerBound and UpperBound
CI.count.min <- as.numeric(apply(df.boot.count,1,function(x)sort(as.numeric(x))[0.025*Nite]))
CI.count.max <- as.numeric(apply(df.boot.count,1,function(x)sort(as.numeric(x))[0.975*Nite]))
CI.perc.min <- as.numeric(apply(df.boot.perc,1,function(x)sort(as.numeric(x))[0.025*Nite]))
CI.perc.max <- as.numeric(apply(df.boot.perc,1,function(x)sort(as.numeric(x))[0.975*Nite]))
lot.count.min <- as.numeric(apply(df.lot.count,1,function(x)sort(as.numeric(x))[0.025*Nite]))
lot.count.max <- as.numeric(apply(df.lot.count,1,function(x)sort(as.numeric(x))[0.975*Nite]))
lot.perc.min <- as.numeric(apply(df.lot.perc,1,function(x)sort(as.numeric(x))[0.025*Nite]))
lot.perc.max <- as.numeric(apply(df.lot.perc,1,function(x)sort(as.numeric(x))[0.975*Nite]))
#Gather all results
df.ORP <- cbind (df.perc,
CI.count.min, CI.count.max, CI.perc.min, CI.perc.max,
lot.count.min, lot.count.max, lot.perc.min, lot.perc.max)
#print(df.ORP)
#Graphic representation
#Taxa count
plot.count <-
ggplot(df.ORP, aes(x=as.numeric(rownames(df.ORP)), y=hist.perc.counts))+
geom_ribbon(aes(ymin=lot.count.min, ymax=lot.count.max),fill="grey90")+
geom_errorbar(aes(ymin=CI.count.min, ymax=CI.count.max), width=0) +
geom_point()+
theme_bw()+
theme(
text=element_text(size=8),
legend.title=element_text(size=8),
legend.text=element_text(size=8),
axis.title=element_text(size=8),
axis.text=element_text(size=8),
# plot.title = element_text(size=12),
panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank(),
panel.grid.minor.y = element_blank())+
scale_y_continuous(breaks=seq(0,70,10),limits=c(0,70))+
scale_x_continuous(breaks=seq(0,1,0.1),limits=c(0,1))+
labs(x="Occurence ratio", y="Number of taxa", title=data[[2]])
#Taxa perc
plot.perc <-
ggplot(df.ORP, aes(x=as.numeric(rownames(df.ORP)), y=hist.perc.perc))+
geom_ribbon(aes(ymin=lot.perc.min, ymax=lot.perc.max),fill="grey90")+
geom_errorbar(aes(ymin=CI.perc.min, ymax=CI.perc.max), width=0) +
geom_point()+
theme_bw()+
theme(
text=element_text(size=8),
legend.title=element_text(size=8),
legend.text=element_text(size=8),
axis.title=element_text(size=8),
axis.text=element_text(size=8),
#plot.title = element_text(size=12),
panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank(),
panel.grid.minor.y = element_blank())+
scale_y_continuous(breaks=seq(0,80,10),limits=c(0,80))+
scale_x_continuous(breaks=seq(0,1,0.1),limits=c(0,1))+
labs(x="Occurence ratio", y="% of taxa", title="")
ggarrange(plot.count, plot.perc)
}
multi.ORP <- lapply(list.ORP, ORP, Nite=9999, right=TRUE)
plot.ORP <- ggarrange(plotlist=multi.ORP,ncol=1,nrow=5)
plot.ORP
ggsave(file="ORP_ammonoid.svg",
plot=plot.ORP, width = 160, height = 247 , units="mm")
Remove_single <- function(data){
data[[1]] <- as.data.frame(t(data[[1]]))
data[[1]] <- data[[1]] %>% mutate(Somme = rowSums(data[[1]]), RowNames = rownames(data[[1]])) %>% filter(Somme != 1)
rownames(data[[1]]) <- data[[1]]$RowNames
data[[1]] <- data[[1]] %>% select(-Somme, -RowNames)
data[[1]] <- as.data.frame(t(data[[1]]))
return(data)
}
list.data.nos <- lapply(list.data,Remove_single)
#Transformer les tableaux d'incidence en matrices de dissimilaritÃ© (une pour chaque intervalle de temps)
Dice.nos <- lapply(list.data.nos, function(data){
data[[1]] <-
labdsv::dsvdis(as.data.frame(data[[1]]),
index="sorensen",
step=0.0,diag=FALSE, upper=FALSE)
return(data)
})
Multi_analysis <- function(data) {
#PCOA
pco_dice <- labdsv::pco(data[[1]],k=2)
pco1 <- pco_dice$eig[1]/sum(pco_dice$eig)*100
pco2 <- pco_dice$eig[2]/sum(pco_dice$eig)*100
mst_pco_dice <- emstreeR::ComputeMST(pco_dice$points)
g <- ggplot(data = mst_pco_dice, aes(x = V1, y = V2, from=from, to=to))+
geom_point()+
theme_bw()+
theme(
axis.title.x = element_text(size=10),
axis.title.y = element_text(size=10),
axis.text.x = element_text(size=8),
axis.text.y = element_text(size=8),
plot.title = element_text(size=12))+
# ggtitle(paste(data[[2]], "w/o singletons"))+
ggtitle(data[[2]])+
stat_MST(colour="red")+
geom_text_repel(aes(label=rownames(pco_dice$points)),size=3)+
labs(y = paste("PCoA 2 (", format(round(pco2,2),nsmall=2), "%)"),
x = paste("PCoA 1 (", format(round(pco1,2),nsmall=2), "%)"))
#UPGMA
UPGMA_dice <- stats::hclust(data[[1]], method = "average", members = NULL)
d <- ggdendrogram(UPGMA_dice, rotate = FALSE, size = 2)+
theme(axis.text.x = element_text(size = 8))
#Graphic gathering
ggarrange(g,d)
}
multi.analysis <- lapply(Dice.nos, Multi_analysis)
multi.plot <- ggarrange(plotlist=multi.analysis,ncol=1,nrow=5)
multi.plot
ggsave(file="PCoA_UPGMA_ammonoid_no singleton.svg",
plot=multi.plot, width=10, height=20, units = "cm")
#Get table of principal axes
VarexDice <- lapply(Dice.nos, function(data){
pco_dice <- labdsv::pco(data[[1]],k=2)
Var <- (pco_dice$eig/sum(pco_dice$eig))*100
}
)
Varex_Dice <- data.frame(lapply(VarexDice, "length<-", max(lengths(VarexDice))))
colnames(Varex_Dice) <- c("Changhsingian","Griesbachian","Dienerian","Spathian","Smithian")
Varex_Dice
write.csv2(x = Varex_Dice, file="PCoA axes_ammonoid.csv")
CoordDice.nos <- lapply(Dice.nos, function(data){
pco_dice <- labdsv::pco(data[[1]],k=2)
pco.point <- pco_dice$points
}
)
#### BSN ANALYSIS ####
list.BSN <-list(Changhsingian = list.data.nos$Changhsingian$Ch,
Griesbachian = list.data.nos$Griesbachian$Gr,
Dienerian = list.data.nos$Dienerian$Di,
Smithian = list.data.nos$Smithian$Sm,
Spathian = list.data.nos$Spathian$Sp
)
BSN <- function(data){
##2. Minimum Spanning Network (msn)
paupau.quad <- function(data){
#dist <- adespatial::dist.ldc(data, method="ab.simpson", binary=TRUE, samp=FALSE, silent=TRUE)
dist <- labdsv::dsvdis(data, index="sorensen", step=0.0, diag=FALSE, upper=FALSE)
df.dist <- metagMisc::dist2list(dist, tri = TRUE)
colnames(df.dist) <- c("col","row","weight")
df.dist$col <- as.character(df.dist$col)
df.dist$row <- as.character(df.dist$row)
df.dist.sort <- df.dist %>% dplyr::arrange(weight)
df.dist.sort
edg <- c()
for (i in 1:nrow(df.dist.sort)) {
#print(paste("i=",i))
edg <- c(edg,
df.dist.sort[i,1],df.dist.sort[i,2])
if (rlang::is_empty(row.names(data)[!row.names(data) %in% edg])) {
n <- length(edg)/2
df.dist.sort.msn <- df.dist.sort[1:n,]
msn <- igraph::graph_from_data_frame(df.dist.sort.msn, directed=FALSE)
}
else{next}
if(igraph::is_connected(msn)==FALSE){next}
else if (igraph::is_connected(msn)==TRUE){
m <- max(which(df.dist.sort$weight==df.dist.sort$weight[i]))
}
break}
msn.edgelist <- df.dist.sort[1:m,]
msn.graph <- igraph::graph_from_data_frame(msn.edgelist, directed=FALSE)
}
graph.test <- paupau.quad(data)
# plot(graph.test)
# igraph::E(graph.test)$weight
##3. Boostrapping
nboot <- 9999
boot <- lapply(vector("list", nboot),
function(x){
boots <- sample(data, replace = TRUE)
}
)
boot.msn <- lapply(boot, paupau.quad)
boot.msn <- c(list(graph.test), boot.msn)
summary(as.factor(unlist(lapply(boot.msn, igraph::is_connected))))
##Calculate bootstrap values
n <- vcount(graph.test)
bootstrap_values <- matrix(0, nrow = n, ncol = n,
dimnames = list(V(graph.test)$name,
V(graph.test)$name))
for (i in 1:length(boot.msn)) {
boot_msn_edges <- get.edgelist(boot.msn[[i]])
for (j in 1:nrow(boot_msn_edges)) {
bootstrap_values[boot_msn_edges[j, 1],
boot_msn_edges[j, 2]] <-
bootstrap_values[boot_msn_edges[j, 1],
boot_msn_edges[j, 2]] + 1
}
}
bootstrap_values <- bootstrap_values+t(bootstrap_values)
bootstrap_values <- bootstrap_values / length(boot.msn)
bootstrap_values[lower.tri(bootstrap_values)] <- NA
bootstrap_values <- round(bootstrap_values, digits=3)
##Loop through edges of msn and assign bootstrap values
amsn <- graph.test
for (i in 1:length(E(amsn))) {
from <- ends(amsn, E(amsn)[i])[1]
to <- ends(amsn, E(amsn)[i])[2]
E(amsn)$bootstrap[i] <- bootstrap_values[from, to]
}
# plot(amsn)
# igraph::get.data.frame(amsn) %>% arrange(bootstrap)
##4. BSN
cat("\n", "NEW BSN", "\n")
amsn.df.sort <- igraph::as_data_frame(amsn) %>% dplyr::arrange(desc(bootstrap))
amsn.sort <- igraph::graph_from_data_frame(amsn.df.sort, directed=FALSE)
amsn.comp <- amsn.sort
v <- make_empty_graph(directed = FALSE, n = vcount(amsn.sort)) %>% set_vertex_attr("name", value = V(amsn.sort)$name)
n <- length(E(amsn))
for(i in n:1){ #For each edge of the msn, from the weakest to the strongest bs
amsn.df.sort <- igraph::as_data_frame(amsn.sort) %>% dplyr::arrange(desc(bootstrap))
amsn.sort <- igraph::graph_from_data_frame(amsn.df.sort, directed=FALSE)
sub.amsn <- delete_edges(amsn.sort, edges=E(amsn.sort)[i]) #Remove the edge and...
#print(is_connected(sub.amsn))
if (!is_connected(sub.amsn)  ){ #...evaluate the connectivity of the network
cat( #A message appears if this edge is crucial for the network
E(amsn.sort)[[i]],
as_ids(E(amsn.sort)[[i]]),
"WARNING DISCONNECTION: kept",
"\n"
)
next
}
simp <- igraph::all_simple_paths(amsn.sort, amsn.df.sort[i,1], amsn.df.sort[i,2], cutoff=6)
len <- sapply(simp, length)
simp.sort <- simp[order(len) - 1]
comp <- as.vector(unlist(lapply(simp.sort, function(x){
g <- make_empty_graph(directed = FALSE, n = vcount(amsn.sort)) %>% set_vertex_attr("name", value = V(amsn.sort)$name)
g2 <- g + path(x)
amsn.sort.sub <- #A subgraph of the msn is then computed with only the alternative path to keep the associated bs
subgraph.edges(amsn.sort, eids=E(amsn.sort, P=as.vector(t(get.edgelist(g2)))), delete.vertices = TRUE)
prod(E(amsn.sort.sub)$bootstrap) > E(amsn.sort)$bootstrap[i]
})))
if (length(which(comp==TRUE)) > 0){ #replace by TRUE
l <- min(which(comp==TRUE))
cat( #A message appears...
i,
as_ids(E(amsn.sort)[[i]]),
"is",
"weaker than",
as_ids(simp.sort[[l]]),
"(",l,"/",length(comp),")",
"\n"
)
if(i==1){
#print(i)
amsn.sort <- delete_edges(amsn.sort, E(amsn.sort)[i])
break
}
else if(E(amsn.sort)$bootstrap[i] == E(amsn.sort)$bootstrap[i-1]){
v <- v + edge(amsn.df.sort[i,1], amsn.df.sort[i,2])
#print(as_ids(E(v)))
}
else{
v <- v + edge(amsn.df.sort[i,1], amsn.df.sort[i,2])
#print(as_ids(E(v)))
amsn.sort <- amsn.sort - v
}
}
else{
cat( #A message appears...
i,
"There is no stronger edge than",
as_ids(E(amsn.sort)[[i]]),
"nsimp =",length(comp),
"\n"
)
}
}
#plot(amsn.sort)
#get.data.frame(amsn.sort) %>% arrange(desc(bootstrap))
return(amsn.sort)
}
multi.BSN <- lapply(list.BSN, BSN)
#Graphic representation
data.BSN <- list(Changhsingian = list(Changhsingian = multi.BSN$Changhsingian,
coopco = CoordDice.nos$Changhsingian,
name="Changhsingian"),
Griesbachian = list(Griesbachian = multi.BSN$Griesbachian,
coopco = CoordDice.nos$Griesbachian,
name="Griesbachian"),
Dienerian = list(Dienerian = multi.BSN$Dienerian,
coopco = CoordDice.nos$Dienerian,
name="Dienerian"),
Smithian = list(Smithian = multi.BSN$Smithian,
coopco = CoordDice.nos$Smithian,
name="Smithian"),
Spathian = list(Spathian = multi.BSN$Spathian,
coopco = CoordDice.nos$Spathian,
name="Spathian")
)
graph.BSN <- function(data){
width <- E(data[[1]])$bootstrap
width[which(width==1)] <- 5.5
width[which(width<1 & width>=0.9)] <- 4
width[which(width<0.9 & width>=0.8)] <- 2.5
width[which(width<0.8)] <- 1
E(data[[1]])$width <- width
colfuncV <- viridis# colorRampPalette(c("black","grey90"))#
colfuncI <- viridis_pal(option="inferno", direction=-1)
colors <- c(colfuncV(50), colfuncI(51))
colors.weight <- colors[(E(data[[1]])$weight*100)+1]
# svg(filename=paste("BSN_ammonoid ",data[[3]],".svg"), width = 10, height = 3)
par(mfrow=c(1,3))
#simple representation in a circle
layout.circle <- layout_in_circle(data[[1]])
plot.circle <-
plot(data[[1]], layout=layout.circle, main=data[[3]],
edge.color=colors.weight,
vertex.size=5, vertex.color="black", vertex.frame.color=NA,
vertex.label.color="black")
#matching with pco axes
coopco <- data[[2]][match(V(data[[1]])$name,
rownames(data[[2]])),]
lo.pco <- norm_coords(coopco,
xmin=min(coopco[,1]), xmax=max(coopco[,1]),
ymin=min(coopco[,2]), ymax=max(coopco[,2]))
plot.pcoa <-
plot.igraph(data[[1]], rescale=F, layout=lo.pco, main="BSN vs PCoA",
xlim = c(min(coopco[,1]), max(coopco[,1])),
ylim = c(min(coopco[,2]), max(coopco[,2])),
edge.color=colors.weight,
vertex.size=1.5, vertex.color="black", vertex.frame.color=NA,
vertex.label.color="black")
#matching with paleocoord
coord <- paleocoord.cent[rownames(paleocoord.cent)%in%V(data[[1]])$name,]
coord <- coord[match(V(data[[1]])$name, rownames(coord)),]
print(coord)
# lo.coord <- norm_coords(as.matrix(coord),
#                         xmin=min(coord$OffPaleolong), xmax=max(coord$OffPaleolong),
#                         ymin=min(coord$OffPaleolat), ymax=max(coord$OffPaleolat))
# plot.palgeo <-
#   plot.igraph(data[[1]], rescale=F, layout=lo.coord, main="BSN vs paleogeography",
#               xlim = c(0, 381),
#               ylim = c(-90, 90),
#               edge.color=colors.weight,
#               vertex.size=5, vertex.color="black", vertex.frame.color=NA,
#               vertex.label.color="black")
# dev.off()
}
multi.graph.BSN <- lapply(data.BSN, graph.BSN)
#Save data table
data.BSN.table <- lapply(data.BSN, function(data){
data.table <- igraph::as_data_frame(data[[1]])
data.table <- data.table %>% tibble::rownames_to_column(var="Edge")
colnames(data.table) <- c("Edge", "Region 1", "Region 2", "Dice index", "Bootstrap support")
write.csv2(x = data.table, file=paste("BSN_data_ammonoid",data[[3]],".csv"), row.names = FALSE)
return(data.table)
})
Ch <- list.data.nos$Changhsingian$Ch[!rownames(list.data.nos$Changhsingian$Ch)%in%c("Gre","SalR","Thai"),]
group.Ch <- t(data.frame("group"=c("N-Tethys","S-Tethys","N-Tethys","N-Tethys","S-Tethys"),
row.names=rownames(Ch)))
Gr <- list.data.nos$Griesbachian$Gr[!rownames(list.data.nos$Griesbachian$Gr)%in%c("SalR","Pri"),]
group.Gr <- t(data.frame("group"=c("N-Panthalassa","N-Panthalassa","Tethys","Tethys","N-Panthalassa","Tethys","N-Panthalassa"),
row.names=rownames(Gr)))
Di <- list.data.nos$Dienerian$Di[!rownames(list.data.nos$Dienerian$Di)%in%c("Nev","Bri"),]
group.Di <- t(data.frame("group"=c("N-Panthalassa","Tethys","Tethys","N-Panthalassa","Tethys","Tethys"),
row.names=rownames(Di)))
Sm <- list.data.nos$Smithian$Sm[!rownames(list.data.nos$Smithian$Sm)%in%c("Ala","Jpn","Cau","Afg","Vie","Pri","Mon"),]
group.Sm <- t(data.frame("group"=c("South","N-Panthalassa","N-Panthalassa","South","South","South","South","N-Panthalassa","South","N-Panthalassa"),
row.names=rownames(Sm)))
Sp <-  list.data.nos$Spathian$Sp[!rownames(list.data.nos$Spathian$Sp)%in%c("Sib","Jpn","Vie","Qin","Pri","Yug"),]
group.Sp <- t(data.frame("group"=c("Equator","Equator","N-Panthalassa","N-Panthalassa","Equator","Equator","N-Panthalassa","S-Tethys","Equator","Equator","S-Tethys"),
row.names=rownames(Sp)))
list.biocores <- list(Ch=Ch, Gr=Gr, Di=Di, Sm=Sm, Sp=Sp)
dice.biocores <- lapply(list.biocores, function(data){
distance <- labdsv::dsvdis(data,
index="sorensen",
step=0.0,diag=FALSE, upper=FALSE)
return(distance)
})
anosim.simper.data <-list(
Changhsingian = list(Changhsingian = Ch, dist = dice.biocores$Ch, group = group.Ch, name="Changhsingian"),
Griesbachian = list(Griesbachian = Gr, dist = dice.biocores$Gr, group = group.Gr, name="Griesbachian"),
Dienerian = list(Dienerian = Di, dist = dice.biocores$Di, group = group.Di, name="Dienerian"),
Smithian = list(Smithian = Sm, dist = dice.biocores$Sm, group = group.Sm, name = "Smithian"),
Spathian = list(Spathian = Sp, dist = dice.biocores$Sp, group = group.Sp, name="Spathian"))
anosimper <- lapply(anosim.simper.data, function(data){
#ANOSIM
anosim.analysis <- vegan::anosim(x = data[[2]],
grouping = as.factor(data[[3]]),
permutation=9999, distance=NULL, strata=NULL, parallel=NULL)
print(data[[4]])
print(anosim.analysis)
#SIMPER
simper.analysis <- vegan::simper(data[[1]], as.factor(data[[3]]), permutations = 9999)
}
)
sapply(names(anosimper), function (x) write.csv2(as.data.frame(anosimper[[x]][[1]]),
file=paste0("SIMPER_data_ammonoid_", x, ".csv"),
row.names = FALSE))
anosimper.name <- lapply(anosimper, function(data){
for (i in 1:length(data)) {
data[[i]]$name <- strsplit(names(data), split = "_")
}
return(data)
}
)
anosimper.name$Changhsingian$`N-Tethys_S-Tethys`$time <- "Changhsingian"
anosimper.name$Griesbachian$`N-Panthalassa_Tethys`$time <- "Griesbachian"
anosimper.name$Dienerian$`N-Panthalassa_Tethys`$time <- "Dienerian"
anosimper.name$Smithian$`South_N-Panthalassa`$time <- "Smithian"
anosimper.name$Spathian$`Equator_N-Panthalassa`$time <- "Spathian"
anosimper.name$Spathian$`Equator_S-Tethys`$time <- "Spathian"
anosimper.name$Spathian$`N-Panthalassa_S-Tethys`$time <- "Spathian"
simper.plot <- lapply(anosimper.name, function(data){
for (i in 1:length(data)) {
repartition <- cbind(as.data.frame(data[[i]]$average),
as.data.frame(data[[i]]$ava),
as.data.frame(data[[i]]$avb)) %>%
rownames_to_column(var="name")
colnames(repartition) <- c("name", "average", data[[i]]$name[[i]][1], data[[i]]$name[[i]][2])
name.order <- as.factor(repartition[order(repartition$average, decreasing = T),c('name')])
df <- reshape2::melt(repartition[,c("name", data[[i]]$name[[i]][1], data[[i]]$name[[i]][2])], id.vars=1)
simper.analysis.data <- full_join(
as.data.frame(cbind("order"=data[[i]]$ord, "cumsum"=data[[i]]$cusum)) %>% rownames_to_column(var="species"),
as.data.frame(cbind("contrib"=data[[i]]$average)) %>% rownames_to_column(var="species")
)
simper.profile.plot <-
ggplot(simper.analysis.data,
aes(x=as.numeric(row.names(simper.analysis.data)), y=contrib))+
geom_point(color="grey50")+
geom_point(aes(y=cumsum/20),color="black")+
scale_y_continuous(name = "Contributive", breaks = seq(0,0.1,0.01), #expand=c(0,0),
sec.axis = sec_axis(~.*20, name = "Cumulative", breaks=seq(0,1,0.1)))+
theme_bw()+
geom_text(data=simper.analysis.data[1:10,],
aes(x=as.numeric(row.names(simper.analysis.data[1:10,])),y=cumsum/20,
label=species,hjust=-0.1, fontface = "italic"),
size=2,color="black")+
theme(
axis.text.x = element_blank(),
axis.text.y = element_text(size=6),
axis.title = element_text(size=6),
axis.ticks.x = element_blank(),
panel.grid.major.x = element_blank(),
legend.position = "none")+
labs(x=NULL)
simper.repartition.plot <-
ggplot(df,aes(x=factor(name, levels=name.order), y=value)) +
geom_bar(aes(fill = variable),stat = "identity",position = "dodge")+
scale_fill_manual(values=c("#fde725ff","#414687ff"))+
theme_bw()+
theme(
axis.text.x = element_text(size=6, angle=75, hjust=1, face="italic"),
axis.title.x = element_blank(),
axis.text.y = element_text(size=6),
axis.title.y = element_text(size=6),
legend.text = element_text(size=6),
legend.title = element_blank(),
legend.position = "right")+
scale_y_continuous(breaks=seq(0,1,0.1),limits=c(0,1), expand=c(0,0))+
labs(y="Distribution (%)")
g <- ggarrange(simper.profile.plot,simper.repartition.plot, ncol=2, nrow=1, widths=c(1,3))
print(g)
ggsave(file=paste("SIMPER_ammonoid",data[[i]]$time,"_",paste(data[[i]]$name[[i]], sep = " ", collapse="_"),".svg"),
plot=g, width=200, height=50, unit="mm")
}
}
)
#Two or three biocores per time interval (by pair)
DNCI.1 <- lapply(anosim.simper.data, function(data){
if(length(unique(data[[3]][1,]))==2){
dnci.ses <- DNCImper:::DNCI.ses(x=as.data.frame(data[[1]]),
grouping=data[[3]][1,],
id=data[[4]],
Nperm=1000,
count=FALSE,
#symmetrize=FALSE,
plotSIMPER=FALSE)
return(dnci.ses)
}
if(length(unique(data[[3]][1,]))==3){
dnci.ses.all <- DNCImper:::DNCI.ses_overall(x=as.data.frame(data[[1]]),
grouping=as.factor(data[[3]][1,]),
id = data[[4]],
#NbrReRun = 5,
Nperm = 1000,
count = FALSE,
plotSIMPER = FALSE)
names(dnci.ses.all) <- c("id","group1","group2","DNCI","CI.DNCI","S.DNCI")
return(dnci.ses.all)
}
})
DNCI.df.1 <- as.data.frame(do.call(rbind, DNCI.1))
write.csv2(x=DNCI.df.1, file="DNCI_data_ammonoid.csv", row.names = FALSE)
DNCI.plot.1 <-
ggplot(data=DNCI.df.1, mapping = aes(x=DNCI, y=factor(id, levels=c("Changhsingian","Griesbachian","Dienerian","Smithian","Spathian"))))+
geom_point(size=1)+
geom_errorbarh(aes(xmin=DNCI-S.DNCI, xmax=DNCI+S.DNCI),height=0,linewidth=0.5)+
theme_bw()+
theme(
axis.title.x = element_text(size=9),
axis.text.x = element_text(size=8),
axis.text.y = element_text(size=9)
)+
# scale_x_continuous(limits=c(min.DNCI,max.DNCI))+
labs(x="DNCI", y="")
DNCI.plot.1
ggsave(file="DNCI_ammonoid.svg", plot=DNCI.plot.1,
width=83, height=83, units = "mm")
